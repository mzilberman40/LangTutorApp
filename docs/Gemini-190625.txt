Техническая документация API Langs2Brain v0.1
1. Обзор и архитектура
Langs2Brain — это бэкенд-сервис для приложения по изучению языков, спроектированный для помощи пользователям в расширении и углублении их словарного запаса.

Ключевые архитектурные принципы:

Изоляция данных: Все данные строго привязаны к конкретному пользователю. API гарантирует, что пользователь может получить доступ только к своим собственным данным.
Асинхронность: Все долгие и ресурсоемкие операции (взаимодействие с LLM для перевода, валидации, генерации примеров) вынесены в фоновые задачи с использованием Celery и Redis. Это обеспечивает быстрый отклик API.
"Resolve then Create": Для обеспечения высокого качества данных, добавление новых слов происходит в два этапа: сначала асинхронное "разрешение" леммы (поиск вариантов частей речи), затем создание конкретной словарной единицы.
Асинхронная валидация: После создания или обновления, каждая словарная единица проходит фоновую проверку на лингвистическую корректность, результат которой сохраняется в базе данных, не блокируя при этом работу пользователя.
2. Аутентификация
Все эндпоинты API по умолчанию защищены и требуют аутентификации. В текущей конфигурации используется SessionAuthentication.

Для работы с API через Swagger UI в режиме разработки, самый простой способ — это открыть в соседней вкладке браузера админ-панель Django (/admin/), войти под своей учетной записью и обновить страницу Swagger. Ваша сессия будет автоматически использована для всех запросов к API.

3. Основные рабочие процессы
3.1. Паттерн асинхронных операций
Большинство ключевых операций следует единому паттерну:

Запуск: Клиент отправляет запрос на специальный эндпоинт (например, /resolve-lemma/ или .../translate/).
Ответ: API немедленно отвечает статусом 202 Accepted и возвращает task_id.
Проверка: Клиент использует task_id для периодических запросов к эндпоинту GET /api/task-status/{task_id}/, чтобы отследить завершение задачи.
Результат: Когда статус задачи меняется на SUCCESS, клиент может либо получить результат из ответа task-status, либо (если задача не возвращает данных) проверить изменения через другие эндпоинты API.
3.2. Добавление новой лексической единицы
POST /api/resolve-lemma/: Отправьте { "lemma": "word", "language": "en-GB" }. Это запустит асинхронную задачу по поиску всех частей речи для этого слова. Скопируйте task_id из ответа.
GET /api/task-status/{task_id}/: Опрашивайте этот эндпоинт, пока статус не станет SUCCESS. В поле result будет массив вариантов (часть речи, произношение).
POST /api/lexical-units/: Выбрав один из вариантов, создайте конкретную словарную единицу, отправив полный объект, включая lemma, language и part_of_speech.
4. Справочник по API эндпоинтам
4.1. Lexical Units (/api/lexical-units/)
Управляет основными словарными единицами пользователя.

POST /: Создает одну или несколько LU.
Одиночное создание: Тело запроса — один JSON-объект.
JSON

{ "lemma": "ephemeral", "language": "en-GB", "part_of_speech": "adj" }
Массовое создание: Тело запроса — JSON-массив объектов.
JSON

[
  { "lemma": "mitigate", "language": "en-GB", "part_of_speech": "verb" },
  { "lemma": "discrepancy", "language": "en-GB", "part_of_speech": "noun" }
]
GET /: Возвращает список всех LU текущего пользователя.
GET /{id}/: Возвращает один LU по его ID.
PATCH /{id}/: Частично обновляет LU.
DELETE /{id}/: Удаляет LU.
Кастомные действия:

POST /{id}/translate/: Запускает асинхронную задачу перевода.
Тело запроса: { "target_language_code": "ru" }
Ответ: 202 Accepted с task_id.
POST /{id}/generate-phrases/: Запускает асинхронную задачу генерации фраз-примеров.
Тело запроса: { "target_translation_language": "ru", "cefr": "C1" }
Ответ: 202 Accepted с task_id.
POST /{id}/enrich-details/: Запускает асинхронную задачу для поиска всех вариантов частей речи и произношения для существующей LU (полезно для LU, созданных без POS).
Ответ: 202 Accepted с task_id.
4.2. Lexical Unit Translations (/api/lexical-unit-translations/)
Управляет связями-переводами между LU.

GET /: Возвращает список всех связей-переводов.
POST /bulk-create/: Мощный эндпоинт для создания исходного LU и нескольких его переводов за один запрос. Если LU не существуют, они будут созданы автоматически.
Тело запроса:
JSON

{
  "source_unit": { "lemma": "versatile", "language": "en-GB", "part_of_speech": "adj" },
  "targets": [
    { "lemma": "универсальный", "language": "ru", "part_of_speech": "adj" },
    { "lemma": "vielseitig", "language": "de", "part_of_speech": "adj" }
  ]
}
Ответ: 201 Created с массивом созданных объектов-связей.
4.3. Phrases и Phrase Translations
/api/phrases/: Стандартный CRUD для фраз-примеров.
/api/phrase-translations/: Стандартный CRUD для связей-переводов между фразами.
5. Ключевые модели данных
LexicalUnit: Центральная модель. Содержит lemma, language, part_of_speech, user, status, а также новые поля validation_status и validation_notes для системы фоновой проверки.
Phrase: Модель для хранения фраз-примеров, с указанием текста, языка и уровня CEFR.
...Translation: Модели-связки для организации отношений "многие-ко-многим" между переводами.